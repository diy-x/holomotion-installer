use anyhow::{anyhow, Result};
use chrono::Local;
use clap::{Arg, ArgAction, ArgGroup, ArgMatches, Command};
use regex::Regex;
use std::cmp::Ordering;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command as StdCommand;

const VERSION: &str = "2.5.0";
const PUBLISH_DATE: &str = "2024-09-01";

#[derive(Debug, Clone, PartialEq)]
enum Channel {
    Master,
    Release,
}

impl Channel {
    fn from_str(s: &str) -> Result<Self> {
        match s.to_lowercase().as_str() {
            "master" => Ok(Channel::Master),
            "release" => Ok(Channel::Release),
            _ => Err(anyhow!("Invalid channel: {}. Available channels: master, release", s)),
        }
    }

    fn as_str(&self) -> &'static str {
        match self {
            Channel::Master => "master",
            Channel::Release => "release",
        }
    }
}

#[derive(Debug)]
enum Action {
    GetCurrentChannel,
    GetCurrentVersion,
    GetLatestVersion,
    Install,
    Upgrade,
    Uninstall,
    Launch,
    CreateDesktop,
    RemoveDesktop,
    DebugTags,
    Status,
    ForceRefresh,
    UpdateGitUrl,
}

#[derive(Debug)]
struct Config {
    action: Action,
    channel: Option<Channel>,
    kill_pid: Option<u32>,
    launch_after: bool,
    app_name: String,
    git_url: Option<String>,
}

impl Config {
    fn from_matches(matches: &ArgMatches) -> Result<Self> {
        let action = Self::determine_action(matches)?;

        let channel = matches
            .get_one::<String>("channel")
            .map(|s| Channel::from_str(s))
            .transpose()?;
        let kill_pid = matches.get_one::<u32>("kill").copied();
        let launch_after = matches.get_flag("launch");
        let app_name = if let Some(name) = matches.get_one::<String>("app-name") {
            name.to_string()
        } else if let Some(detected_name) = HoloMotionInstaller::detect_app_name_from_current_dir() {
            detected_name
        } else {
            "HoloMotion".to_string()
        };

        let git_url = matches
            .get_one::<String>("git-url")
            .or_else(|| matches.get_one::<String>("update-git-url"))
            .map(|s| s.to_string());

        Ok(Config {
            action,
            channel,
            kill_pid,
            launch_after,
            app_name,
            git_url,
        })
    }

    fn determine_action(matches: &ArgMatches) -> Result<Action> {
        if matches.get_flag("get-current-channel") || matches.get_flag("current-channel") {
            Ok(Action::GetCurrentChannel)
        } else if matches.get_flag("get-current-version") || matches.get_flag("current-version") {
            Ok(Action::GetCurrentVersion)
        } else if matches.get_flag("get-latest-version") || matches.get_flag("latest-version") {
            Ok(Action::GetLatestVersion)
        } else if matches.get_flag("install") {
            Ok(Action::Install)
        } else if matches.get_flag("upgrade") {
            Ok(Action::Upgrade)
        } else if matches.get_flag("uninstall") {
            Ok(Action::Uninstall)
        } else if matches.get_flag("launch-only") {
            Ok(Action::Launch)
        } else if matches.get_flag("create-desktop") {
            Ok(Action::CreateDesktop)
        } else if matches.get_flag("remove-desktop") {
            Ok(Action::RemoveDesktop)
        } else if matches.get_flag("debug-tags") {
            Ok(Action::DebugTags)
        } else if matches.get_flag("status") {
            Ok(Action::Status)
        } else if matches.get_flag("force-refresh") {
            Ok(Action::ForceRefresh)
        } else if matches.contains_id("update-git-url") {
            Ok(Action::UpdateGitUrl)
        } else {
            Err(anyhow!("No action specified"))
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Version {
    major: u32,
    minor: u32,
    patch: u32,
    pre_release: Option<String>,
    build_metadata: Option<String>,
    raw: String,
}

impl Version {
    fn parse(version_str: &str) -> Result<Self> {
        let raw = version_str.to_string();

        let date_regex = Regex::new(r"^(\d+)\.(\d+)\.(\d+)-(\d{8})$")?;
        if let Some(captures) = date_regex.captures(version_str) {
            return Ok(Version {
                major: captures[1].parse()?,
                minor: captures[2].parse()?,
                patch: captures[3].parse()?,
                pre_release: Some(captures[4].to_string()),
                build_metadata: None,
                raw,
            });
        }

        let semver_regex = Regex::new(r"^(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z\-\.]+))?(?:\+([0-9A-Za-z\-\.]+))?$")?;
        if let Some(captures) = semver_regex.captures(version_str) {
            return Ok(Version {
                major: captures[1].parse()?,
                minor: captures[2].parse()?,
                patch: captures[3].parse()?,
                pre_release: captures.get(4).map(|m| m.as_str().to_string()),
                build_metadata: captures.get(5).map(|m| m.as_str().to_string()),
                raw,
            });
        }

        Err(anyhow!("Invalid version format: {}", version_str))
    }
    fn is_release(&self) -> bool {
        self.pre_release.is_none()
    }

    fn is_date_version(&self) -> bool {
        self.pre_release
            .as_ref()
            .map(|pr| pr.len() == 8 && pr.chars().all(|c| c.is_ascii_digit()))
            .unwrap_or(false)
    }
}

impl Ord for Version {
    fn cmp(&self, other: &Self) -> Ordering {
        match self.major.cmp(&other.major) {
            Ordering::Equal => {},
            other => return other,
        }
        match self.minor.cmp(&other.minor) {
            Ordering::Equal => {},
            other => return other,
        }

        match self.patch.cmp(&other.patch) {
            Ordering::Equal => {},
            other => return other,
        }

        match(&self.pre_release, &other.pre_release) {
            (None, None) => Ordering::Equal,
            (None, Some(_)) => Ordering::Greater,
            (Some(_), None) => Ordering::Less,
            (Some(a), Some(b)) => {
                if self.is_date_version() && other.is_date_version() {
                    a.cmp(b)
                } else {
                    a.cmp(b)
                }
            }
        }
    }
}

impl PartialOrd for Version {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

struct HoloMotionInstaller {
    app_name: String,
    ntsport_dir: PathBuf,
    program_dir: PathBuf,
    caching_dir: PathBuf,
    startup_bin: PathBuf,
    installer_bin: PathBuf,
    branch_file: PathBuf,
    git_file: PathBuf,
}

impl HoloMotionInstaller {
    fn detect_app_name_from_current_dir() -> Option<String> {
        if let Ok(current_dir) = std::env::current_dir() {
            if let Some(dir_name) = current_dir.file_name() {
                if let Some(dir_str) = dir_name.to_str() {
                    if dir_str.starts_with("HoloMotion") {
                        return Some(dir_str.to_string());
                    }
                }
            }
        }
        None
    }

    fn new(app_name: Option<&str>) -> Result<Self> {
        let home_dir = dirs::home_dir()
            .ok_or_else(|| anyhow!("Could not determine home directory"))?;

        let app_name = if let Some(name) = app_name {
            name.to_string()
        } else if let Some(detected_name) = Self::detect_app_name_from_current_dir() {
            println!("üîç Ëá™Âä®Ê£ÄÊµãÂà∞Â∫îÁî®ÂêçÁß∞: {}", detected_name);
            detected_name
        } else {
            "HoloMotion".to_string()
        };

        let ntsport_dir = home_dir.join("local/bin/ntsports");
        let program_dir = ntsport_dir.join(&app_name);
        let caching_dir = home_dir.join("Documents/HoloMotion_log");

        let startup_bin = home_dir.join("local/bin").join(&app_name);
        let installer_bin = home_dir.join("local/bin").join(format!("{}_Update", &app_name));
        let branch_file = program_dir.join("branch.txt");
        let git_file = program_dir.join("git.txt");

        Ok(Self {
            app_name,
            ntsport_dir,
            program_dir,
            caching_dir,
            startup_bin,
            installer_bin,
            branch_file,
            git_file,
        })
    }

    fn log(&self, message: &str) {
        let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S%.3f");
        println!("{}", message);

        if let Ok(log_dir) = self.ensure_log_dir() {
            let log_file = log_dir.join(format!("{}.log", Local::now().format("%Y%m%d")));
            if let Ok(mut file) = fs::OpenOptions::new()
                .create(true)
                .append(true)
                .open(&log_file)
            {
                let _ = writeln!(file, "{} : {}", timestamp, message);
            }
        }
    }

    fn ensure_log_dir(&self) -> Result<PathBuf> {
        let log_dir = self.caching_dir.join("log/update");
        fs::create_dir_all(&log_dir)?;
        Ok(log_dir)
    }

    fn fix_permissions(&self) -> Result<()> {
        self.log("Ê≠£Âú®‰øÆÊ≠£Á®ãÂ∫èÊâßË°åÊùÉÈôê...");

        let files_to_chmod = vec![
            self.program_dir.join("HoloMotion_Update_installer_new.sh"),
            self.program_dir.join("NT.Client.sh"),
            self.program_dir.join("NT.Client"),
            self.program_dir.join("NT.Config.sh"),
            self.program_dir.join("NT.Config"),
        ];

        for file_path in files_to_chmod {
            if file_path.exists() {
                let output = StdCommand::new("chmod")
                    .args(&["777", file_path.to_string_lossy().as_ref()])
                    .output()?;
                if output.status.success() {
                    self.log(&format!("chmod 777 {}", file_path.display()));
                }
            }
        }

        self.log("ÊùÉÈôê‰øÆÊ≠£ÂÆåÊàê");
        Ok(())
    }

    fn is_valid_git_url(&self, url: &str) -> bool {
        let url = url.trim();
        if url.is_empty() {
            return false;
        }

        let patterns = vec![
            Regex::new(r"^https://[^/\s]+/.+$").unwrap(),
            Regex::new(r"^http://[^/\s]+/.+$").unwrap(),
            Regex::new(r"^git@[^:\s]+:.+$").unwrap(),
            Regex::new(r"^ssh://git@[^/\s]+/.+$").unwrap(),
            Regex::new(r"^file://.+$").unwrap(),
        ];

        if !patterns.iter().any(|pattern| pattern.is_match(url)) {
            return false;
        }

        if url.contains("://") {
            let parts: Vec<&str> = url.split("://").collect();
            if parts.len() != 2 {
                return false;
            }

            let protocol = parts[0];
            let rest = parts[1];

            let valid_protocols = ["http", "https", "ssh", "git", "file"];
            if !valid_protocols.contains(&protocol) {
                return false;
            }

            if protocol == "file" {
                return !rest.is_empty();
            }

            if rest.contains('/') {
                let url_parts: Vec<&str> = rest.split('/').collect();
                if url_parts.len() < 2 {
                    return false;
                }
                let domain = url_parts[0];
                return !domain.is_empty();
            }
        } else if url.starts_with("git@") {
            if !url.contains(':') {
                return false;
            }
            let parts: Vec<&str> = url.split(':').collect();
            if parts.len() < 2 {
                return false;
            }
            let host_part = parts[0];
            let path_part = parts[1];
            return host_part.starts_with("git@") && !path_part.is_empty();
        }

        true
    }

    fn test_git_connectivity(&self, git_url: &str) -> Result<bool> {
        self.log(&format!("Ê≠£Âú®ÊµãËØïGit‰ªìÂ∫ìËøûÈÄöÊÄß: {}", git_url));

        let output = StdCommand::new("git")
            .args(&["ls-remote", "--heads", git_url])
            .output();

        match output {
            Ok(result) => {
                if result.status.success() {
                    self.log("‚úì Git‰ªìÂ∫ìËøûÈÄöÊÄßÊµãËØïÈÄöËøá");
                    Ok(true)
                } else {
                    let stderr = String::from_utf8_lossy(&result.stderr);
                    self.log(&format!("‚ö† Git‰ªìÂ∫ìËøûÈÄöÊÄßÊµãËØïÂ§±Ë¥•: {}", stderr));
                    Ok(false)
                }
            }
            Err(e) => {
                self.log(&format!("‚ö† GitËøûÈÄöÊÄßÊµãËØïÊâßË°åÂ§±Ë¥•: {}", e));
                Ok(false)
            }
        }
    }

    /// **‰øÆÂ§çÔºö‰ºòÂÖà‰ΩøÁî®git.txtÁöÑGit URLËé∑ÂèñÈÄªËæë**
    fn get_git_url(&self, provided_git_url: Option<&str>) -> Result<String> {
        // **‰ºòÂÖàÁ∫ß1Ôºögit.txtÊñá‰ª∂‰∏≠ÁöÑÈÖçÁΩÆ**
        if self.git_file.exists() {
            match fs::read_to_string(&self.git_file) {
                Ok(content) => {
                    let git_url = content.trim().to_string();
                    if !git_url.is_empty() {
                        self.log(&format!("‚úÖ ‰ºòÂÖà‰ΩøÁî®git.txtÈÖçÁΩÆÊñá‰ª∂‰∏≠ÁöÑGit‰ªìÂ∫ìÂú∞ÂùÄ: {}", git_url));
                        return Ok(git_url);
                    } else {
                        self.log("‚ö† git.txtÊñá‰ª∂Â≠òÂú®‰ΩÜÂÜÖÂÆπ‰∏∫Á©∫ÔºåÂ∞ùËØï‰ΩøÁî®Áî®Êà∑Êèê‰æõÁöÑURL");
                    }
                }
                Err(e) => {
                    self.log(&format!("‚ö† ËØªÂèñgit.txtÊñá‰ª∂Â§±Ë¥•: {},Â∞ùËØï‰ΩøÁî®Áî®Êà∑Êèê‰æõÁöÑURL", e));
                }
            }
        } else {
            self.log("‚Ñπ git.txtÊñá‰ª∂‰∏çÂ≠òÂú®ÔºåÂ∞Ü‰ΩøÁî®Áî®Êà∑Êèê‰æõÁöÑURL");
        }

        // **‰ºòÂÖàÁ∫ß2ÔºöÁî®Êà∑‰º†ÂÖ•ÁöÑGit URL**
        if let Some(git_url) = provided_git_url {
            self.log(&format!("üì• ‰ΩøÁî®Áî®Êà∑Êèê‰æõÁöÑGit‰ªìÂ∫ìÂú∞ÂùÄ: {}", git_url));

            if !self.is_valid_git_url(git_url) {
                self.log(&format!("‚ö† Git URLÊ†ºÂºèÊ£ÄÊü•Â§±Ë¥•Ôºå‰ΩÜ‰ªçÂ∞ÜÂ∞ùËØï‰ΩøÁî®: {}", git_url));
            } else {
                self.log("‚úÖ Git URLÊ†ºÂºèÈ™åËØÅÈÄöËøá");
            }

            if let Ok(connected) = self.test_git_connectivity(git_url) {
                if !connected {
                    self.log("‚ö† Git‰ªìÂ∫ìËøûÈÄöÊÄßÊµãËØïÂ§±Ë¥•Ôºå‰ΩÜÂ∞ÜÁªßÁª≠Â∞ùËØï");
                }}

            //Âè™ÊúâÂú®git.txt‰∏çÂ≠òÂú®Êàñ‰∏∫Á©∫Êó∂Êâç‰øùÂ≠ò
            if !self.git_file.exists() ||
                fs::read_to_string(&self.git_file).map(|s| s.trim().is_empty()).unwrap_or(true) {
                if let Err(e) = self.save_git_url(git_url) {
                    self.log(&format!("‚ö† Êó†Ê≥ï‰øùÂ≠òGitÈÖçÁΩÆÂà∞Êñá‰ª∂: {}", e));
                } else {
                    self.log("üíæ Êñ∞ÁöÑGit‰ªìÂ∫ìÂú∞ÂùÄÂ∑≤‰øùÂ≠òÂà∞ÈÖçÁΩÆÊñá‰ª∂");
                }
            }

            return Ok(git_url.to_string());
        }Err(anyhow!("‚ùå Êú™ÊâæÂà∞Git‰ªìÂ∫ìÈÖçÁΩÆ„ÄÇËØ∑‰ΩøÁî® --git-url ÂèÇÊï∞ÊåáÂÆö‰ªìÂ∫ìÂú∞ÂùÄÔºåÊàñÁ°Æ‰øù git.txt Êñá‰ª∂Â≠òÂú®"))
    }

    fn update_git_url(&self, new_git_url: &str) -> Result<()> {
        self.log(&format!("üîÑ Âº∫Âà∂Êõ¥Êñ∞Git‰ªìÂ∫ìÂú∞ÂùÄ: {}", new_git_url));

        if !self.is_valid_git_url(new_git_url) {
            return Err(anyhow!("‚ùå Êó†ÊïàÁöÑGit URLÊ†ºÂºè: {}", new_git_url));
        }

        if !self.test_git_connectivity(new_git_url)? {
            return Err(anyhow!("‚ùå Git‰ªìÂ∫ìËøûÈÄöÊÄßÊµãËØïÂ§±Ë¥•: {}", new_git_url));
        }

        self.save_git_url(new_git_url)?;

        if self.repos_exist() {
            let output = StdCommand::new("git")
                .args(&["remote", "set-url", "origin", new_git_url])
                .current_dir(&self.program_dir)
                .output()?;

            if !output.status.success() {
                return Err(anyhow!("‚ùå Êõ¥Êñ∞ËøúÁ®ã‰ªìÂ∫ìURLÂ§±Ë¥•"));
            }

            self.log("üîó GitËøúÁ®ã‰ªìÂ∫ìURLÂ∑≤Êõ¥Êñ∞");
        }

        self.log("‚úÖ GitÈÖçÁΩÆÊõ¥Êñ∞ÂÆåÊàê");
        Ok(())
    }

    fn save_git_url(&self, git_url: &str) -> Result<()> {
        if let Some(parent_dir) = self.git_file.parent() {
            fs::create_dir_all(parent_dir)?;
        }

        fs::write(&self.git_file, git_url)?;
        self.log(&format!("üíæ Git‰ªìÂ∫ìÂú∞ÂùÄÂ∑≤‰øùÂ≠òËá≥: {}", self.git_file.display()));
        Ok(())
    }

    fn get_current_remote_url(&self) -> Result<String> {
        if !self.repos_exist() {
            return Err(anyhow!("Repository does not exist"));
        }

        let output = StdCommand::new("git")
            .args(&["remote", "get-url", "origin"])
            .current_dir(&self.program_dir)
            .output()?;

        if !output.status.success() {
            return Err(anyhow!("Failed to get current remote URL"));
        }

        let url = String::from_utf8(output.stdout)?.trim().to_string();
        Ok(url)
    }

    fn ensure_correct_remote(&self, provided_git_url: Option<&str>) -> Result<()> {
        if !self.repos_exist() {
            return Ok(());
        }

        let expected_url = self.get_git_url(provided_git_url)?;

        let current_url = match self.get_current_remote_url() {
            Ok(url) => url,
            Err(_) => {
                self.log("‚ö† Êó†Ê≥ïËé∑ÂèñÂΩìÂâçËøúÁ®ã‰ªìÂ∫ìURL");
                return Ok(());
            }
        };

        let normalize_url = |url: &str| -> String {
            url.trim()
                .trim_end_matches('/')
                .trim_end_matches(".git")
                .to_lowercase()
        };

        if normalize_url(&expected_url) != normalize_url(&current_url) {
            self.log(&format!("üîÑ Ê£ÄÊµãÂà∞ËøúÁ®ã‰ªìÂ∫ìURL‰∏çÂåπÈÖç"));
            self.log(&format!("ÂΩìÂâç: {}", current_url));
            self.log(&format!("ÊúüÊúõ: {}", expected_url));
            self.log("Ê≠£Âú®Êõ¥Êñ∞ËøúÁ®ã‰ªìÂ∫ìURL...");

            let output = StdCommand::new("git")
                .args(&["remote", "set-url", "origin", &expected_url])
                .current_dir(&self.program_dir)
                .output()?;

            if !output.status.success() {
                return Err(anyhow!("Failed to update remote origin URL"));
            }

            self.log("‚úÖ ËøúÁ®ã‰ªìÂ∫ìURLÂ∑≤Êõ¥Êñ∞");
        } else {
            self.log("‚úÖ ËøúÁ®ã‰ªìÂ∫ìURLÊ£ÄÊü•ÈÄöËøá");
        }

        Ok(())
    }

    fn fetch_remote(&self) -> Result<()> {
        if !self.repos_exist() {
            return Err(anyhow!("Repository does not exist"));
        }

        self.log("üîÑ Ê≠£Âú®Ëé∑ÂèñËøúÁ®ã‰ªìÂ∫ìÊúÄÊñ∞‰ø°ÊÅØ...");

        let _ = StdCommand::new("git")
            .args(&["remote", "prune", "origin"])
            .current_dir(&self.program_dir)
            .output();

        let output = StdCommand::new("git")
            .args(&["fetch", "origin", "--tags", "--force", "--prune-tags"])
            .current_dir(&self.program_dir)
            .output()?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            self.log(&format!("‚ö† Fetch Ë≠¶Âëä/ÈîôËØØ: {}", stderr));
            let output2 = StdCommand::new("git")
                .args(&["fetch", "--all", "--tags", "--force"])
                .current_dir(&self.program_dir)
                .output()?;
            if !output2.status.success() {
                let stderr2 = String::from_utf8_lossy(&output2.stderr);
                return Err(anyhow!("‚ùå Failed to fetch from remote: {}", stderr2));
            }
        }

        let output = StdCommand::new("git")
            .args(&["tag", "-l", "--sort=-version:refname"])
            .current_dir(&self.program_dir)
            .output()?;
        if output.status.success() {
            let tags = String::from_utf8(output.stdout)?;
            let tag_count = tags.lines().count();
            self.log(&format!("‚úÖ ËøúÁ®ã‰ªìÂ∫ì‰ø°ÊÅØËé∑ÂèñÂÆåÊàêÔºåÂÖ± {} ‰∏™Ê†áÁ≠æ", tag_count));

            let latest_tags: Vec<&str> = tags.lines().take(5).collect();
            self.log(&format!("üè∑Ô∏è ÊúÄÊñ∞Ê†áÁ≠æ: {:?}", latest_tags));
        }

        Ok(())
    }

    fn clean_git_state(&self) -> Result<()> {
        self.log("üßπ Ê≠£Âú®Ê∏ÖÁêÜGitÂ∑•‰ΩúÁõÆÂΩïÁä∂ÊÄÅ...");

        let _ = StdCommand::new("git")
            .args(&["reset", "--hard", "HEAD"])
            .current_dir(&self.program_dir)
            .output();

        let _ = StdCommand::new("git")
            .args(&["clean", "-fd"])
            .current_dir(&self.program_dir)
            .output();

        let _ = StdCommand::new("git")
            .args(&["checkout", "."])
            .current_dir(&self.program_dir)
            .output();

        self.log("‚úÖ GitÂ∑•‰ΩúÁõÆÂΩïÁä∂ÊÄÅÊ∏ÖÁêÜÂÆåÊàê");
        Ok(())
    }

    fn force_refresh_tags(&self) -> Result<()> {
        self.log("üîÑ Âº∫Âà∂Âà∑Êñ∞ËøúÁ®ãÊ†áÁ≠æ‰ø°ÊÅØ...");

        if !self.repos_exist() {
            return Err(anyhow!("Repository does not exist"));
        }

        let output = StdCommand::new("git")
            .args(&["tag", "-l"])
            .current_dir(&self.program_dir)
            .output()?;
        if output.status.success() {
            let tags = String::from_utf8(output.stdout)?;
            if !tags.trim().is_empty() {
                self.log("üóëÔ∏è Âà†Èô§ÊâÄÊúâÊú¨Âú∞Ê†áÁ≠æ...");
                for tag in tags.lines() {
                    let _ = StdCommand::new("git")
                        .args(&["tag", "-d", tag])
                        .current_dir(&self.program_dir)
                        .output();
                }
                self.log("‚úÖ Êú¨Âú∞Ê†áÁ≠æÂ∑≤Ê∏ÖÁêÜ");
            }
        }

        let output = StdCommand::new("git")
            .args(&["fetch", "origin", "--tags", "--force"])
            .current_dir(&self.program_dir)
            .output()?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("‚ùå Failed to fetch tags: {}", stderr));
        }

        self.log("‚úÖ ËøúÁ®ãÊ†áÁ≠æÂà∑Êñ∞ÂÆåÊàê");
        Ok(())
    }

    fn repos_exist(&self) -> bool {
        self.program_dir.exists() && self.program_dir.join(".git").exists()
    }

    fn assert_repos_exist(&self) -> Result<()> {
        if !self.repos_exist() {
            return Err(anyhow!("‚ùå Application not installed. Please use --install first!"));
        }
        Ok(())
    }

    fn get_current_channel(&self, provided_git_url: Option<&str>) -> Result<Channel> {
        self.log("üîç Ëé∑ÂèñÂΩìÂâçÂÆâË£ÖÈÄöÈÅì");

        if self.branch_file.exists() {
            let channel_str = fs::read_to_string(&self.branch_file)?;
            let channel = Channel::from_str(channel_str.trim())?;
            self.log(&format!("üìÅ ‰ªéÈÖçÁΩÆÊñá‰ª∂ËØªÂèñÈÄöÈÅì: {}", channel.as_str()));
            return Ok(channel);
        }

        self.assert_repos_exist()?;
        self.log("‚Ñπ ÈÖçÁΩÆÊñá‰ª∂‰∏çÂ≠òÂú®ÔºåÊ†πÊçÆ‰ªìÂ∫ìÊ†áÁ≠æÂà§Êñ≠ÈÄöÈÅì");

        self.ensure_correct_remote(provided_git_url)?;
        self.fetch_remote()?;

        let output = StdCommand::new("git")
            .args(&["describe", "--tags"])
            .current_dir(&self.program_dir)
            .output()?;

        if !output.status.success() {
            return Err(anyhow!("Failed to get git describe output"));
        }

        let raw_version = String::from_utf8(output.stdout)?.trim().to_string();
        self.log(&format!("üìã Git describe ÂéüÂßãËæìÂá∫: {}", raw_version));

        let version = self.extract_version_from_git_describe(&raw_version)?;
        self.log(&format!("üî¢ ÊèêÂèñÁöÑÁâàÊú¨Âè∑: {}", version));

        let channel = if let Ok(parsed_version) = Version::parse(&version) {
            if parsed_version.is_date_version() {
                Channel::Release
            } else if parsed_version.is_release() {
                Channel::Master
            } else {
                Channel::Release
            }
        } else {
            Channel::Release
        };

        fs::write(&self.branch_file, channel.as_str())?;
        self.log(&format!("üíæ ÂΩìÂâçÂÆâË£ÖÈÄöÈÅì: {}", channel.as_str()));

        Ok(channel)
    }

    fn extract_version_from_git_describe(&self, raw_version: &str) -> Result<String> {
        let mut version = raw_version.to_string();
        if version.starts_with("refs/tags/") {
            version = version.strip_prefix("refs/tags/").unwrap().to_string();
        }
        if version.contains('/') {
            let parts: Vec<&str> = version.split('/').collect();
            if let Some(last_part) = parts.last() {
                version = last_part.to_string();
            }
        }

        let git_suffix_regex = Regex::new(r"-\d+-g[a-f0-9]+$")?;
        version = git_suffix_regex.replace(&version, "").to_string();

        if version.starts_with('v') && version.len() > 1 {
            version = version[1..].to_string();
        }

        Ok(version)
    }

    fn get_current_version(&self, channel: &Channel, provided_git_url: Option<&str>) -> Result<String> {
        self.log("üîç Ëé∑ÂèñÂ∑≤ÂÆâË£ÖÁâàÊú¨Âè∑");
        self.assert_repos_exist()?;
        self.log(&format!("üìç ÂΩìÂâçÈÄöÈÅì: {}", channel.as_str()));

        self.ensure_correct_remote(provided_git_url)?;

        let output = StdCommand::new("git")
            .args(&["describe", "--tags"])
            .current_dir(&self.program_dir)
            .output()?;

        if !output.status.success() {
            return Err(anyhow!("Failed to get git describe output"));
        }

        let raw_version = String::from_utf8(output.stdout)?.trim().to_string();
        self.log(&format!("üìã Git describe ÂéüÂßãËæìÂá∫: {}", raw_version));

        let version = self.extract_version_from_git_describe(&raw_version)?;
        self.log(&format!("üî¢ Â§ÑÁêÜÂêéÁöÑÁâàÊú¨Âè∑: {}", version));

        if Version::parse(&version).is_ok() {
            Ok(version)
        } else {
            Err(anyhow!("‚ùå Version format does not match expected pattern: {}", version))
        }
    }

    fn get_latest_version(&self, channel: &Channel, provided_git_url: Option<&str>) -> Result<String> {
        self.log("üîç Ëé∑ÂèñÊúÄÊñ∞ÁâàÁâàÊú¨Âè∑");
        self.assert_repos_exist()?;
        self.log(&format!("üìç ÂΩìÂâçÈÄöÈÅì: {}", channel.as_str()));

        self.ensure_correct_remote(provided_git_url)?;
        self.fetch_remote()?;

        self.log("üì° ÊñπÊ≥ï1: ‰ΩøÁî® git ls-remote Ëé∑ÂèñËøúÁ®ãÊ†áÁ≠æ");
        let output = StdCommand::new("git")
            .args(&["ls-remote", "--tags", "--refs", "origin"])
            .current_dir(&self.program_dir)
            .output()?;

        let mut versions_method1 = Vec::new();
        if output.status.success() {
            let tags_output = String::from_utf8(output.stdout)?;
            for line in tags_output.lines() {
                if let Some(tag_part) = line.split("refs/tags/").nth(1) {
                    if let Ok(version_str) = self.extract_version_from_git_describe(tag_part) {
                        if let Ok(version) = Version::parse(&version_str) {
                            let should_include = match channel {
                                Channel::Release => version.is_release() || version.is_date_version(),
                                Channel::Master => true,
                            };
                            if should_include {
                                versions_method1.push(version);
                            }
                        }
                    }
                }
            }
        }

        self.log("üíæ ÊñπÊ≥ï2: ‰ΩøÁî®Êú¨Âú∞Ê†áÁ≠æÂàóË°®‰Ωú‰∏∫Â§áÈÄâ");
        let output = StdCommand::new("git")
            .args(&["tag", "-l", "--sort=-version:refname"])
            .current_dir(&self.program_dir)
            .output()?;

        let mut versions_method2 = Vec::new();
        if output.status.success() {
            let tags_output = String::from_utf8(output.stdout)?;
            for line in tags_output.lines().take(100) {
                if let Ok(version_str) = self.extract_version_from_git_describe(line) {
                    if let Ok(version) = Version::parse(&version_str) {
                        let should_include = match channel {
                            Channel::Release => version.is_release() || version.is_date_version(),
                            Channel::Master => true,
                        };
                        if should_include {
                            versions_method2.push(version);
                        }
                    }
                }
            }
        }

        let mut versions = if versions_method1.len() >= versions_method2.len() {
            self.log(&format!("üìä ‰ΩøÁî®ÊñπÊ≥ï1ÁªìÊûúÔºåËé∑ÂèñÂà∞ {} ‰∏™ÁâàÊú¨", versions_method1.len()));
            versions_method1
        } else {
            self.log(&format!("üìä ‰ΩøÁî®ÊñπÊ≥ï2ÁªìÊûúÔºåËé∑ÂèñÂà∞ {} ‰∏™ÁâàÊú¨", versions_method2.len()));
            versions_method2
        };

        if versions.is_empty() {
            return Err(anyhow!("‚ùå Ê≤°ÊúâÊâæÂà∞Á¨¶ÂêàÈÄöÈÅì {} ÁöÑÊúâÊïàÁâàÊú¨", channel.as_str()));
        }

        versions.sort();
        let latest = versions.last().unwrap();
        self.log(&format!("üìà ÊâæÂà∞ {} ‰∏™ÊúâÊïàÁâàÊú¨", versions.len()));
        self.log(&format!("üéØ ËøúÁ´ØÊúÄÊñ∞ÁâàÊú¨: {}", latest.raw));
        Ok(latest.raw.clone())
    }

    fn kill_process(&self, pid: u32) -> Result<()> {
        self.log(&format!("üî™ Ê≠£Âú®ÂÖ≥Èó≠ËøõÁ®ã: {}", pid));

        let output = StdCommand::new("kill")
            .args(&["-9", &pid.to_string()])
            .output()?;

        if output.status.success() {
            self.log("‚úÖ ËøõÁ®ãÂ∑≤ÂÖ≥Èó≠");
        } else {
            self.log("‚ö† ÂÖ≥Èó≠ËøõÁ®ãÂ§±Ë¥•ÊàñËøõÁ®ã‰∏çÂ≠òÂú®");
        }

        Ok(())
    }

    fn clean_installed(&self) -> Result<()> {
        self.log("üßπ ÂºÄÂßãÊ∏ÖÁêÜ");

        if self.program_dir.exists() {
            fs::remove_dir_all(&self.program_dir)?;
            self.log("‚úÖ Â∑≤Ê∏ÖÁêÜÁ®ãÂ∫èÁõÆÂΩï");
        }

        if self.startup_bin.exists() {
            fs::remove_file(&self.startup_bin)?;
            self.log("‚úÖ Â∑≤Ê∏ÖÁêÜÂêØÂä®ËÑöÊú¨");
        }

        if self.installer_bin.exists() {
            fs::remove_file(&self.installer_bin)?;
            self.log("‚úÖ Â∑≤Ê∏ÖÁêÜÂÆâË£ÖÂô®ËÑöÊú¨");
        }

        if self.caching_dir.exists() {
            fs::remove_dir_all(&self.caching_dir)?;
            self.log("‚úÖ Â∑≤Ê∏ÖÁêÜÁºìÂ≠òÊï∞ÊçÆ");
        }

        self.log("üéâ Ê∏ÖÁêÜÂÆåÊàê");
        Ok(())
    }

    fn install(&self, channel: &Channel, provided_git_url: Option<&str>) -> Result<()> {
        self.log("üöÄ ÂºÄÂßãÂÆâË£Ö");
        self.log(&format!("üìç Â∫îÁî®: {}, ÈÄöÈÅì: {}", self.app_name, channel.as_str()));

        let git_url = self.get_git_url(provided_git_url)?;
        self.log(&format!("üîó ‰ΩøÁî®Git‰ªìÂ∫ì: {}", git_url));

        self.clean_installed()?;

        fs::create_dir_all(&self.ntsport_dir)?;
        self.log(&format!("üìÅ ÂàõÂª∫Á®ãÂ∫èÂÆâË£ÖÁõÆÂΩï: {:?}", self.ntsport_dir));

        self.log("‚¨áÔ∏è Ê≠£Âú®‰∏ãËΩΩÁ®ãÂ∫è");
        let output = StdCommand::new("git")
            .args(&["clone", &git_url, &self.program_dir.to_string_lossy()])
            .current_dir(&self.ntsport_dir)
            .output()?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("‚ùå Failed to clone repository: {}\nÈîôËØØËØ¶ÊÉÖ: {}", git_url, stderr));
        }

        let _ = StdCommand::new("git")
            .args(&["config", "--global", "--add", "safe.directory", &self.program_dir.to_string_lossy()])
            .output();

        if provided_git_url.is_some() && !self.git_file.exists() {
            self.save_git_url(&git_url)?;
        }

        self.fetch_remote()?;
        let latest_version = self.get_latest_version(channel, provided_git_url)?;
        self.log(&format!("üîÑ Ê≠£Âú®ÂàáÊç¢Âà∞ÁâàÊú¨: {}", latest_version));

        let output = StdCommand::new("git")
            .args(&["checkout", &latest_version])
            .current_dir(&self.program_dir)
            .output()?;

        if !output.status.success() {
            let output = StdCommand::new("git")
                .args(&["reset", "--hard", &latest_version])
                .current_dir(&self.program_dir)
                .output()?;
            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                return Err(anyhow!("‚ùå ÂàáÊç¢Âà∞ÊúÄÊñ∞ÁâàÊú¨Â§±Ë¥•: {}", stderr));
            }
        }

        self.create_symlinks()?;
        self.fix_permissions()?;

        fs::write(&self.branch_file, channel.as_str())?;
        self.log(&format!("üíæ ÂÜôÂÖ•ÈÖçÁΩÆÊñá‰ª∂: channel={}", channel.as_str()));

        self.log(&format!("üéâ ÂÆâË£ÖÂÆåÊàê! ÁâàÊú¨: {}", latest_version));
        Ok(())
    }

    fn create_symlinks(&self) -> Result<()> {
        self.log("üîó Ê≠£Âú®ÂàõÂª∫Á¨¶Âè∑ÈìæÊé•...");

        let install_src = self.program_dir.join("HoloMotion_Update_installer_new.sh");
        let install_app = self.ntsport_dir.join("HoloMotion_Update_installer_new.sh");

        if install_src.exists() {
            fs::copy(&install_src, &install_app)?;
            self.log(&format!("üìã Â§çÂà∂ÂÆâË£ÖËÑöÊú¨: {}", install_app.display()));

            let _ = StdCommand::new("chmod")
                .args(&["+x", install_app.to_string_lossy().as_ref()])
                .output();

            if self.installer_bin.exists() {
                let _ = fs::remove_file(&self.installer_bin);
            }

            #[cfg(unix)]
            {
                use std::os::unix::fs::symlink;
                if let Ok(_) = symlink(&install_app, &self.installer_bin) {
                    self.log(&format!("üîó ÂàõÂª∫ÂÆâË£ÖÂô®Á¨¶Âè∑ÈìæÊé•: {}", self.installer_bin.display()));
                }
            }
        }

        let startup_src = self.program_dir.join("NT.Client.sh");

        if startup_src.exists() {
            if self.startup_bin.exists() {
                let _ = fs::remove_file(&self.startup_bin);
            }

            #[cfg(unix)]
            {
                use std::os::unix::fs::symlink;
                if let Ok(_) = symlink(&startup_src, &self.startup_bin) {
                    self.log(&format!("üîó ÂàõÂª∫ÂêØÂä®ËÑöÊú¨Á¨¶Âè∑ÈìæÊé•: {}", self.startup_bin.display()));
                }
            }

            let _ = StdCommand::new("chmod")
                .args(&["+x", startup_src.to_string_lossy().as_ref()])
                .output();
        }

        let _ = StdCommand::new("hash")
            .arg("-r")
            .output();

        self.log("‚úÖ Á¨¶Âè∑ÈìæÊé•ÂàõÂª∫ÂÆåÊàê");
        Ok(())
    }

    /// **‰øÆÂ§çÁîüÂëΩÂë®ÊúüÈóÆÈ¢òÁöÑupgradeÊñπÊ≥ï**
    fn upgrade(&self, channel: &Channel, provided_git_url: Option<&str>) -> Result<()> {
        self.log("‚¨ÜÔ∏è ÂºÄÂßãÂçáÁ∫ß");
        self.assert_repos_exist()?;

        self.ensure_correct_remote(provided_git_url)?;
        self.fetch_remote()?;

        let current_version = self.get_current_version(channel, provided_git_url)?;
        let latest_version = self.get_latest_version(channel, provided_git_url)?;

        self.log(&format!("üìä ÂΩìÂâçÁâàÊú¨: {}", current_version));
        self.log(&format!("üìä ÊúÄÊñ∞ÁâàÊú¨: {}", latest_version));

        if current_version == latest_version {
            self.log("‚úÖ Â∑≤ÁªèÊòØÊúÄÊñ∞ÁâàÊú¨!");
            return Ok(());
        }

        self.log("üîÑ Ê≠£Âú®Â∫îÁî®Êõ¥Êñ∞");
        self.clean_git_state()?;
        self.fix_permissions()?;

        self.log(&format!("üîÑ Ê≠£Âú®ÂàáÊç¢Âà∞ÁâàÊú¨: {}", latest_version));
        // **‰øÆÂ§çÁîüÂëΩÂë®ÊúüÈóÆÈ¢òÔºöÈ¢ÑÂÖàÂàõÂª∫Â≠óÁ¨¶‰∏≤ÂèòÈáè**
        let fetch_refspec = format!("refs/tags/{}:refs/tags/{}", latest_version, latest_version);
        let tag_ref = format!("tags/{}", latest_version);

        let mut success = false;

        // **ÊñπÊ≥ï1: Áõ¥Êé•checkout**
        self.log("üîÑ Â∞ùËØïÊñπÊ≥ï1: checkout");
        let output = StdCommand::new("git")
            .args(&["checkout", &latest_version])
            .current_dir(&self.program_dir)
            .output()?;

        if output.status.success() {
            success = true;
            self.log("‚úÖ ‰ΩøÁî®checkoutÊñπÂºèÂàáÊç¢ÁâàÊú¨ÊàêÂäü");
        } else {
            // **ÊñπÊ≥ï2: fetchÁâπÂÆötagÁÑ∂Âêéreset**
            self.log("üîÑ Â∞ùËØïÊñπÊ≥ï2: fetch+reset");
            let output = StdCommand::new("git")
                .args(&["fetch", "origin", &fetch_refspec])
                .current_dir(&self.program_dir)
                .output()?;
            if output.status.success() {
                let reset_output = StdCommand::new("git")
                    .args(&["reset", "--hard", &latest_version])
                    .current_dir(&self.program_dir)
                    .output()?;

                if reset_output.status.success() {
                    success = true;
                    self.log("‚úÖ ‰ΩøÁî®fetch+resetÊñπÂºèÂàáÊç¢ÁâàÊú¨ÊàêÂäü");
                }
            }
        }

        if !success {
            // **ÊñπÊ≥ï3: fetch allÁÑ∂Âêéreset**
            self.log("üîÑ Â∞ùËØïÊñπÊ≥ï3: fetch-all+reset");
            let output = StdCommand::new("git")
                .args(&["fetch", "--all"])
                .current_dir(&self.program_dir)
                .output()?;

            if output.status.success() {
                let reset_output = StdCommand::new("git")
                    .args(&["reset", "--hard", &latest_version])
                    .current_dir(&self.program_dir)
                    .output();

                if reset_output.is_ok() && reset_output.unwrap().status.success() {
                    success = true;
                    self.log("‚úÖ ‰ΩøÁî®fetch-all+resetÊñπÂºèÂàáÊç¢ÁâàÊú¨ÊàêÂäü");
                }
            }
        }

        if !success {
            // **ÊñπÊ≥ï4: ÊúÄÂêéÂ∞ùËØï‰ΩøÁî®tagsË∑ØÂæÑ**
            self.log("üîÑ Â∞ùËØïÊñπÊ≥ï4: tagsË∑ØÂæÑ");
            let output = StdCommand::new("git")
                .args(&["reset", "--hard", &tag_ref])
                .current_dir(&self.program_dir)
                .output();

            if output.is_ok() && output.unwrap().status.success() {
                success = true;
                self.log("‚úÖ ‰ΩøÁî®tagsÊñπÂºèÂàáÊç¢ÁâàÊú¨ÊàêÂäü");
            }
        }

        if !success {
            return Err(anyhow!("‚ùå ÊâÄÊúâÁâàÊú¨ÂàáÊç¢ÊñπÂºèÈÉΩÂ§±Ë¥•‰∫Ü"));
        }

        self.create_symlinks()?;
        self.fix_permissions()?;
        fs::write(&self.branch_file, channel.as_str())?;

        self.log(&format!("üéâ ÂçáÁ∫ßÂÆåÊàê! ÁâàÊú¨: {} -> {}", current_version, latest_version));
        Ok(())
    }

    fn uninstall(&self) -> Result<()> {
        self.log("üóëÔ∏è ÂºÄÂßãÂç∏ËΩΩ");
        self.clean_installed()?;
        self.log("üéâ Âç∏ËΩΩÂÆåÊàê!");
        Ok(())
    }

    fn launch(&self) -> Result<()> {
        self.log("üöÄ ÂêØÂä®Á®ãÂ∫è");
        self.assert_repos_exist()?;
        let startup_script = self.program_dir.join("NT.Client.sh");

        if !startup_script.exists() {
            return Err(anyhow!("‚ùå Startup script not found"));
        }

        let _child = StdCommand::new("sh")
            .arg(&startup_script)
            .spawn()?;

        self.log("‚úÖ Á®ãÂ∫èÂ∑≤ÂêØÂä®");
        Ok(())
    }

    fn create_desktop_entry(&self) -> Result<()> {
        let startup_app = self.program_dir.join("NT.Client.sh");
        let startup_png = self.program_dir.join("assets/watermark_logo.png");

        let desktop_content = format!(
            "[Desktop Entry]\n\
Type=Application\n\
Name={}\n\
GenericName={}\n\
Comment={} Application\n\
Exec={}\n\
Icon={}\n\
Terminal=false\n\
Categories=X-Application;\n\
StartupNotify=true\n",
            self.app_name,
            self.app_name,
            self.app_name,
            startup_app.display(),
            startup_png.display()
        );

        let desktop_file = Path::new("/usr/share/applications").join(format!("{}.desktop", self.app_name));
        let home_dir = dirs::home_dir().ok_or_else(|| anyhow!("Cannot get home directory"))?;
        let autostart_file = home_dir
            .join(".config/autostart")
            .join(format!("{}.desktop", self.app_name));

        fs::write(&desktop_file, &desktop_content)?;
        self.log(&format!("üñ•Ô∏è ÂàõÂª∫Á≥ªÁªüÊ°åÈù¢Êñá‰ª∂: {}", desktop_file.display()));

        if let Some(autostart_dir) = autostart_file.parent() {
            fs::create_dir_all(autostart_dir)?;
        }
        fs::write(&autostart_file, &desktop_content)?;
        self.log(&format!("üîÑ ÂàõÂª∫Ëá™Âä®ÂêØÂä®Êñá‰ª∂: {}", autostart_file.display()));

        if let Some(desktop_dir) = dirs::desktop_dir() {
            let desktop_shortcut = desktop_dir.join(format!("{}.desktop", self.app_name));
            fs::write(&desktop_shortcut, &desktop_content)?;
            let _ = StdCommand::new("chmod")
                .args(&["+x", desktop_shortcut.to_string_lossy().as_ref()])
                .output();
            self.log(&format!("üñ±Ô∏è ÂàõÂª∫Ê°åÈù¢Âø´Êç∑ÊñπÂºè: {}", desktop_shortcut.display()));
        }

        let _ = StdCommand::new("chmod")
            .args(&["644", desktop_file.to_string_lossy().as_ref()])
            .output();

        self.log("üéâ Ê°åÈù¢ÂõæÊ†áÂàõÂª∫ÊàêÂäü");
        Ok(())
    }

    fn remove_desktop_entry(&self) -> Result<()> {
        let desktop_files = vec![
            Path::new("/usr/share/applications").join(format!("{}.desktop", self.app_name)),
            dirs::home_dir()
                .unwrap()
                .join(".config/autostart")
                .join(format!("{}.desktop", self.app_name)),
        ];

        let mut removed_count = 0;
        for file in &desktop_files {
            if file.exists() {
                if fs::remove_file(file).is_ok() {
                    removed_count += 1;
                    self.log(&format!("üóëÔ∏è Âà†Èô§Êñá‰ª∂: {}", file.display()));
                }
            }
        }

        if let Some(desktop_dir) = dirs::desktop_dir() {
            let desktop_shortcut = desktop_dir.join(format!("{}.desktop", self.app_name));
            if desktop_shortcut.exists() {
                if fs::remove_file(&desktop_shortcut).is_ok() {
                    removed_count += 1;
                    self.log(&format!("üóëÔ∏è Âà†Èô§Ê°åÈù¢Âø´Êç∑ÊñπÂºè: {}", desktop_shortcut.display()));
                }
            }
        }

        self.log(&format!("üéâ Ê°åÈù¢ÂõæÊ†áÂà†Èô§ÂÆåÊàêÔºåÂÖ±Âà†Èô§ {} ‰∏™Êñá‰ª∂", removed_count));
        Ok(())
    }

    fn debug_list_tags(&self) -> Result<()> {
        self.log("üêõ === Ë∞ÉËØï‰ø°ÊÅØ: ÂΩìÂâç‰ªìÂ∫ìÊ†áÁ≠æ ===");
        self.log(&format!("üì± Â∫îÁî®ÂêçÁß∞: {}", self.app_name));
        self.log(&format!("üìÅ Á®ãÂ∫èÁõÆÂΩï: {:?}", self.program_dir));
        self.log(&format!("üîó ÂêØÂä®ËÑöÊú¨: {:?} (Â≠òÂú®: {})", self.startup_bin, self.startup_bin.exists()));
        self.log(&format!("‚öôÔ∏è ÂÆâË£ÖÂô®ËÑöÊú¨: {:?} (Â≠òÂú®: {})", self.installer_bin, self.installer_bin.exists()));

        if !self.repos_exist() {
            self.log("‚ùå ‰ªìÂ∫ì‰∏çÂ≠òÂú®");
            return Ok(());
        }

        if let Ok(git_url) = self.get_git_url(None) {
            self.log(&format!("üîó ÂΩìÂâçGit‰ªìÂ∫ì: {}", git_url));
        }

        let output = StdCommand::new("git")
            .args(&["tag", "-l", "--sort=-version:refname"])
            .current_dir(&self.program_dir)
            .output()?;
        if output.status.success() {
            let tags = String::from_utf8(output.stdout)?;
            self.log("üè∑Ô∏è Êú¨Âú∞Ê†áÁ≠æ(ÊåâÁâàÊú¨ÊéíÂ∫è):");
            for tag in tags.lines().take(20) {
                self.log(&format!("  üìç {}", tag));
            }
        }

        let output = StdCommand::new("git")
            .args(&["ls-remote", "--tags", "origin"])
            .current_dir(&self.program_dir)
            .output()?;
        if output.status.success() {
            let tags = String::from_utf8(output.stdout)?;
            self.log("üåê ËøúÁ®ãÊ†áÁ≠æ:");
            for line in tags.lines().take(20) {
                self.log(&format!("  üì° {}", line));
            }
        }

        self.log("üêõ === Ë∞ÉËØï‰ø°ÊÅØÁªìÊùü ===");
        Ok(())
    }

    fn check_status(&self) -> Result<()> {
        self.log("üìä === Á≥ªÁªüÁä∂ÊÄÅÊ£ÄÊü• ===");
        self.log(&format!("üì± Â∫îÁî®ÂêçÁß∞: {}", self.app_name));
        self.log(&format!("üìÅ Á®ãÂ∫èÁõÆÂΩï: {:?}", self.program_dir));
        self.log(&format!("üîó ÂêØÂä®ËÑöÊú¨: {:?} (Â≠òÂú®: {})", self.startup_bin, self.startup_bin.exists()));
        self.log(&format!("‚öôÔ∏è ÂÆâË£ÖÂô®ËÑöÊú¨: {:?} (Â≠òÂú®: {})", self.installer_bin, self.installer_bin.exists()));

        if let Ok(git_url) = self.get_git_url(None) {
            self.log(&format!("‚úÖ Git‰ªìÂ∫ìÈÖçÁΩÆ: {}", git_url));
        } else {
            self.log("‚ùå Git‰ªìÂ∫ìÈÖçÁΩÆÊú™ÊâæÂà∞");
        }

        if self.repos_exist() {
            self.log("‚úÖ Â∫îÁî®Á®ãÂ∫èÂ∑≤ÂÆâË£Ö");

            if let Ok(channel) = self.get_current_channel(None) {
                self.log(&format!("üìç ÂΩìÂâçÈÄöÈÅì: {}", channel.as_str()));

                if let Ok(current_version) = self.get_current_version(&channel, None) {
                    self.log(&format!("üî¢ ÂΩìÂâçÁâàÊú¨: {}", current_version));

                    let _ = self.ensure_correct_remote(None);
                    let _ = self.fetch_remote();

                    if let Ok(latest_version) = self.get_latest_version(&channel, None) {
                        self.log(&format!("üéØ ÊúÄÊñ∞ÁâàÊú¨: {}", latest_version));

                        if current_version == latest_version {
                            self.log("‚úÖ Â∑≤ÊòØÊúÄÊñ∞ÁâàÊú¨");
                        } else {
                            self.log(&format!("‚ö†Ô∏è ÂèëÁé∞Êõ¥Êñ∞: {} -> {}", current_version, latest_version));
                        }
                    } else {
                        self.log("‚ùå Êó†Ê≥ïËé∑ÂèñÊúÄÊñ∞ÁâàÊú¨‰ø°ÊÅØ");
                    }
                } else {
                    self.log("‚ùå Êó†Ê≥ïËé∑ÂèñÂΩìÂâçÁâàÊú¨‰ø°ÊÅØ");
                }
            } else {
                self.log("‚ùå Êó†Ê≥ïËé∑ÂèñÈÄöÈÅì‰ø°ÊÅØ");
            }
        } else {
            self.log("‚ùå Â∫îÁî®Á®ãÂ∫èÊú™ÂÆâË£Ö");
        }

        self.log("üìä === Áä∂ÊÄÅÊ£ÄÊü•ÂÆåÊàê ===");
        Ok(())
    }

    fn execute_action(&self, config: &Config) -> Result<()> {
        self.log(&format!("üéØ ÊâßË°åÊìç‰Ωú: {:?}, Â∫îÁî®: {}", config.action, config.app_name));

        if let Some(pid) = config.kill_pid {
            self.kill_process(pid)?;
        }

        let channel = config.channel.clone().unwrap_or_else(|| {
            self.get_current_channel(config.git_url.as_deref()).unwrap_or(Channel::Release)
        });

        match &config.action {
            Action::GetCurrentChannel => {
                let current_channel = self.get_current_channel(config.git_url.as_deref())?;
                println!("{}", current_channel.as_str());
            }
            Action::GetCurrentVersion => {
                let version = self.get_current_version(&channel, config.git_url.as_deref())?;
                println!("{}", version);
            }
            Action::GetLatestVersion => {
                let version = self.get_latest_version(&channel, config.git_url.as_deref())?;
                println!("{}", version);
            }
            Action::Install => {
                self.install(&channel, config.git_url.as_deref())?;
                if config.launch_after {
                    self.launch()?;
                }
            }
            Action::Upgrade => {
                self.upgrade(&channel, config.git_url.as_deref())?;if config.launch_after {
                    self.launch()?;
                }
            }
            Action::Uninstall => {
                self.uninstall()?;
            }
            Action::Launch => {
                self.launch()?;
            }
            Action::CreateDesktop => {
                self.create_desktop_entry()?;
            }
            Action::RemoveDesktop => {
                self.remove_desktop_entry()?;
            }
            Action::DebugTags => {
                self.debug_list_tags()?;
            }
            Action::Status => {
                self.check_status()?;
            }
            Action::ForceRefresh => {
                self.force_refresh_tags()?;
            }
            Action::UpdateGitUrl => {
                if let Some(git_url) = &config.git_url {
                    self.update_git_url(git_url)?;
                } else {
                    return Err(anyhow!("‚ùå Êõ¥Êñ∞Git URLÊó∂ÂøÖÈ°ªÊèê‰æõ--update-git-urlÂèÇÊï∞"));
                }
            }
        }

        Ok(())
    }
}

fn build_cli() -> Command {
    Command::new("HoloMotion Installer")
        .version(VERSION)
        .author("HoloMotion Team")
        .about("HoloMotion application installer and updater with intelligent Git URL management")
        .help_template("\
{before-help}{name} {version}
{author-with-newline}{about-with-newline}
{usage-heading} {usage}

{all-args}

{after-help}")
        .after_help("Examples:
  holomotion-installer --install -b release --git-url https://cnb.cool/nts2025/repo‰ΩøÁî®ÊåáÂÆöGit‰ªìÂ∫ìÂÆâË£Ö
  holomotion-installer --upgrade --name HoloMotion_Test
      ‰ºòÂÖà‰ΩøÁî®git.txtÈÖçÁΩÆËøõË°åÂçáÁ∫ß
  holomotion-installer --update-git-url https://new-repo.com/path --name HoloMotion_Test
      Âº∫Âà∂Êõ¥Êñ∞Git‰ªìÂ∫ìÂú∞ÂùÄholomotion-installer --status
      Ê£ÄÊü•Áä∂ÊÄÅÔºàËá™Âä®Ê£ÄÊµãÂ∫îÁî®ÂêçÁß∞Ôºâ")
        .arg(Arg::new("channel")
            .short('b')
            .value_name("CHANNEL")
            .help("ÊåáÂÆöÈÄöÈÅì: master, release(ÈªòËÆ§)")
            .value_parser(["master", "release"])
            .num_args(1))
        .arg(Arg::new("kill")
            .short('k')
            .value_name("PID")
            .help("ÊåáÂÆöÊâßË°åÂâçÈúÄÊùÄÊ≠ªÁöÑËøõÁ®ã ID")
            .value_parser(clap::value_parser!(u32))
            .num_args(1))
        .arg(Arg::new("launch")
            .short('r')
            .help("Âú®ÂÆâË£ÖÊàñÂçáÁ∫ßÂÆåÊàêÂêéÊòØÂê¶ÂêØÂä®ÂÆ¢Êà∑Á´Ø")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("app-name")
            .short('n')
            .long("name")
            .value_name("APP_NAME")
            .help("ÊåáÂÆöÂ∫îÁî®ÂêçÁß∞ (ÈªòËÆ§: HoloMotion, ÂèØÈÄâ: HoloMotion_Test,ÊîØÊåÅËá™Âä®Ê£ÄÊµã)")
            .num_args(1))
        .arg(Arg::new("git-url")
            .short('g')
            .long("git-url")
            .value_name("GIT_URL")
            .help("ÊåáÂÆöGit‰ªìÂ∫ìÂú∞ÂùÄ (‰ªÖÂú®git.txt‰∏çÂ≠òÂú®Êó∂‰øùÂ≠ò)")
            .num_args(1))

        .arg(Arg::new("get-current-channel")
            .long("get-current-channel")
            .help("Ëé∑ÂèñÂΩìÂâçÂÆâË£ÖÁöÑÈÄöÈÅì")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("current-channel")
            .long("current-channel")
            .help("Ëé∑ÂèñÂΩìÂâçÂÆâË£ÖÁöÑÈÄöÈÅì")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("get-current-version")
            .long("get-current-version")
            .help("Ëé∑ÂèñÂΩìÂâçÂÆâË£ÖÁöÑÁâàÊú¨Âè∑")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("current-version")
            .long("current-version")
            .help("Ëé∑ÂèñÂΩìÂâçÂÆâË£ÖÁöÑÁâàÊú¨Âè∑")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("get-latest-version")
            .long("get-latest-version")
            .help("Ëé∑ÂèñÊúÄÊñ∞ÁöÑÁâàÊú¨Âè∑")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("latest-version")
            .long("latest-version")
            .help("Ëé∑ÂèñÊúÄÊñ∞ÁöÑÁâàÊú¨Âè∑")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("create-desktop")
            .long("create-desktop")
            .help("ÂàõÂª∫Âø´Êç∑ÂêØÂä®ÂõæÊ†á(sudo -E)")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("remove-desktop")
            .long("remove-desktop")
            .help("Âà†Èô§Âø´Êç∑ÂêØÂä®ÂõæÊ†á(sudo -E)")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("install")
            .long("install")
            .help("ÂÆâË£Ö(ÂÆâË£ÖÊúÄÊñ∞ÁâàÂπ∂‰øùÁïôÁºìÂ≠òÊï∞ÊçÆ)")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("uninstall")
            .long("uninstall")
            .help("Âç∏ËΩΩ(‰∏ç‰øùÁïôÁºìÂ≠òÊï∞ÊçÆ)")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("upgrade")
            .long("upgrade")
            .help("ÂçáÁ∫ß")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("version")
            .long("version")
            .short('v')
            .help("ÂÆâË£ÖËÑöÊú¨ÁâàÊú¨‰ø°ÊÅØ")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("launch-only")
            .long("launch")
            .help("ÂêØÂä®ÂÆ¢Êà∑Á´Ø")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("help")
            .long("help")
            .short('h')
            .help("Â∏ÆÂä©‰ø°ÊÅØ")
            .action(ArgAction::SetTrue))

        .arg(Arg::new("debug-tags")
            .long("debug-tags")
            .help("Ë∞ÉËØï: ÂàóÂá∫ÊâÄÊúâÊ†áÁ≠æÂíåË∑ØÂæÑ‰ø°ÊÅØ")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("status")
            .long("status")
            .help("Ê£ÄÊü•Á≥ªÁªüÂíåÂÆâË£ÖÁä∂ÊÄÅ")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("force-refresh")
            .long("force-refresh")
            .help("Âº∫Âà∂Âà∑Êñ∞ËøúÁ®ãÊ†áÁ≠æ")
            .action(ArgAction::SetTrue))
        .arg(Arg::new("update-git-url")
            .long("update-git-url")
            .value_name("GIT_URL")
            .help("Âº∫Âà∂Êõ¥Êñ∞Git‰ªìÂ∫ìÂú∞ÂùÄÂπ∂‰øùÂ≠òÂà∞git.txt")
            .num_args(1))

        .group(ArgGroup::new("action")
            .required(true)
            .args([
                "get-current-channel", "current-channel",
                "get-current-version", "current-version",
                "get-latest-version", "latest-version",
                "install", "upgrade", "uninstall", "launch-only",
                "create-desktop", "remove-desktop",
                "debug-tags", "status", "force-refresh",
                "update-git-url", "version", "help"]))
}

fn main() -> Result<()> {
    let matches = build_cli().get_matches();

    if matches.get_flag("help") {
        build_cli().print_help()?;
        return Ok(());
    }

    if matches.get_flag("version") {
        println!("{} - {}", VERSION, PUBLISH_DATE);
        return Ok(());
    }

    let config = Config::from_matches(&matches)?;
    let installer = HoloMotionInstaller::new(Some(&config.app_name))?;
    installer.execute_action(&config)?;

    Ok(())
}